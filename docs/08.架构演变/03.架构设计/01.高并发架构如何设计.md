---
title: 高并发架构如何设计
date: 2024-05-14 16:14:06
permalink: /pages/a5a764/
---


## 高并发系统的通用设计理念

在应对高并发系统的巨大流量时，通用的设计理念主要分为 3 个方面：`分流` 、 `缓存` 、 `异步` 

### 分流

`分流` 也就是将庞大的流量给分离开来，这样避免了在单点上压力过大的问题

就比如系统高峰期每秒有 10000 个请求，那么你要从硬件层面提升系统的性能，无非只有两种方式：

- **提升机器硬件配置**
- **增加机器** 

但是你要知道，机器硬件配置提升的成本是很大的，并且随着硬件配置的提升所带来的高并发收益 `并不是线性` 的，因此一般在线上生产环境中，我们不会去单单提升硬件配置，而是选用一个合适的配置比如 2C4G 或者 4C8G，将这样的机器多来几个，这样就相比于使用一个 32C64G 的机器所带来的收益要高许多

**因此，在高并发架构中，更倾向于 `低配置多机器部署` ，而不是 `高配置少机器部署`** 

![image-20240229172343613](https://11laile-note-img.oss-cn-beijing.aliyuncs.com/image-20240229172343613.png)

### 缓存

其次就是增加 `缓存` 来提升系统的性能

系统中的数据一般都是 `存在磁盘中` 的，如果每次要查询数据都要去发起磁盘 IO 进行查询，带来的性能开销是比较大的（我们要知道无论是网络 IO 还是磁盘 IO 速度都比较慢）

**所以说有没有比较快的方法呢？**

就是缓存，像我们常用的就是 Redis 缓存，是分布式缓存，如果对并发量有更高的要求，那么可能会再使用 JVM 缓存（Caffeine），进一步加快数据的访问速度

**这里举一个高并发系统的例子：12306 使用 GemFire** 

我们都知道 12306 是一个高并发系统，根据 12306 开发人员介绍，它的性能瓶颈在于余票的查询中，因为它的业务场景比较特殊，所以对查询的需求比较大，那么 12306 就是用了 GemFire 来存储余票数据，GemFire 也是一个内存数据库，于是呢它就将所有的业务数据全部放到了内存中来，由于 GemFire 扩容不便，因此提前估计好业务数据，总共业务数据大约有几十个 T ，因此直接将内存给分配够，就可以将全部的业务数据读取到 GemFire 中来，抗下大量的请求



### 异步

最后呢，就是通过 `异步` 来提升系统的性能

异步就是将比较耗时的操作给异步化，这样 `主干流程就不需要一直阻塞等待耗时的操作执行完毕` 了，可以让主干流程继续向下执行，再找一个地方取一下异步执行的结果就可以了

像我们在系统中常用的异步化操作有 CompletableFuture 和消息队列（MQ）





### 总结

因此在设计高并发系统中，主要性能优化就从以上 3 个方面来进行操作

但是我们一定要提前对于系统要承载的并发量以及团队的人员能力来设计，不要在项目初期就 `过度设计` ，引入过多技术债，导致项目整体很复杂，出现问题定位困难

- 在系统设计初期，在满足业务和流量的基础上，选择熟悉的技术体系！

- 随着业务体量的增长，暴露出了一些性能问题，那么就可以引入一些常用主流的组件来提升性能







## 高性能秒杀系统如何设计？

首先说一下 `案例背景` ：设计一个秒杀系统，秒杀系统的特性就是一瞬间峰值流量很大，远远大于常规时期的流量

如果对于这种峰值流量不采取应对措施的话，那么突然增大的流量就会导致系统负载升高，甚至系统瘫痪，所有业务都崩溃无法使用

### 加机器可以应对吗？

那我们先来思考一下通过添加机器是否可以应对下秒杀流量

那么对于这种尖刺流量，我们要做的第一步就是在活动开始之前，对于请求量进行预估，来给对应的业务增加机器，但是增加机器的话存在两个问题：

![image-20240229194805782](https://11laile-note-img.oss-cn-beijing.aliyuncs.com/image-20240229194805782.png)

第一个问题：**增加机器数量不确定**

如果机器节点增加少了，仍然会导致系统资源不够用的情况；如果机器节点增加多了，比较浪费资源

并且秒杀活动一般就持续几分钟，为了这几分钟来增加大量节点，要做许多运维工作以及评估流量工作，**相对来说效率比较低** 

第二个问题：**个别业务性能与机器数量无关** 

比如说 `扣减库存` 的业务，需要加上分布式锁去扣减库存，那么无论是加多少个机器节点，并发度都不会有提升，那么我们只有去对业务进一步优化，以此来提升系统的性能



### 秒杀应对方案

那么上边说了，通过添加机器会带来许多运维上的复杂度，并且不好评估，那么有没有其他方案来应对秒杀中的尖刺流量呢？

在高并发系统中，应对高并发流量通用的有 3 种方式：`分流` 、 `缓存` 、 `异步` 

**这里就是通过 `异步` 这种方式来应对秒杀中的峰值流量**

在秒杀中，用户一瞬间会发送大量下单请求，如果每一个请求都直接去进行对应的业务处理（扣减库存、生成订单），那么系统在短时间内肯定是处理不完这么多的下单请求的

如果对每一个请求都去进行对应的业务处理，系统处于高负载状态，有些请求就会失败，返回超时提示，于是用户就重新刷新界面，发送更多的请求，对后台系统造成更大的压力，导致系统瘫痪

因此考虑使用对下单请求处理 `异步化` ，当收到下单请求后，不立即进行处理，而是先放入到队列中，下单系统 `根据自己的处理能力` 来队列中取出下单请求进行处理

这样就可以避免整个系统因为处理大量的请求而处于高负载的状态了，整个流程如下：

![image-20240229202804169](https://11laile-note-img.oss-cn-beijing.aliyuncs.com/image-20240229202804169.png)



- **因此经过队列优化后，整个秒杀的下单流程为：**

1、用户提交订单请求，请求进入到队列中，并返回用户一个排队编号

2、用户提交订单后，进入到等待界面中，显示用户前边还有多少请求等待处理，预计多长时间处理完毕

3、当用户的订单被下单系统成功处理之后，将用户界面跳转到支付页面，提示用户进行支付，之后就完成这笔订单

**这就是使用了队列来进行削峰** ，将瞬时的峰值流量给分散铺平，避免系统的不稳定





### 技术选型

上边说到了使用队列对秒杀系统进行优化，**那么队列该如何选型呢？** 

我们常用的消息队列有 RocketMQ、Kafka 等等，这里并没有选用这些消息队列，而是 `使用了 Redis 来实现队列` 

相比于 RocketMQ 这些，Redis 更加轻量，并且基于内存操作，性能更好，使用 Redis 自带的队列数据结构，可以获取 `队列长度` 以及 `请求在队列中的位置` ，可以及时反馈给用户排队进度



- **接下来说一些技术细节** 

**队列分配：** 在 Redis 中给每一个秒杀商品都分配一个队列，这样将大量的请求再分散在多个队列中，队列的进入、退出操作不会成为秒杀的瓶颈，对该商品的下单请求就会进入到对应商品的队列中

**队列调度：** 下单系统根据下单时间和队列长度来 `选择队列` 进行处理，避免某些用户等待较长时间都得不到处理

**队列长度：** 队列长度设置为秒杀商品的 `库存数量` ，当处理完一个请求后，就 `将队列的长度 -1` ，当队列长度为 0 时，说明该商品就已经被抢完了，不要让后边的用户再进入到队列中进行等待了



**秒杀数据库和其他库分离：**

对于秒杀的商品来说，库存扣减的瞬时压力是比较高的，因此可以将秒杀的库单独抽取出来，和常规商品分离，这样也大幅度提升了库存数据库的读写能力

![image-20240229211602014](https://11laile-note-img.oss-cn-beijing.aliyuncs.com/image-20240229211602014.png)

**秒杀系统的可用性：**

在秒杀活动中，如果这个秒杀系统出现问题，我们要有 `兜底方案` 

可以设计常规的商品处理流程为兜底方案，对于用户的请求，可以走 `常规商品处理流程` ，也可以走 `秒杀处理流程` 

这样在秒杀流程出现问题时，可以及时切换回常规商品的处理流程，一定程度上提升系统的可用性（主要是前期秒杀系统上线时，没有经过线上环境的历练，可能会存在一些问题）

![image-20240229211424734](https://11laile-note-img.oss-cn-beijing.aliyuncs.com/image-20240229211424734.png)

 









